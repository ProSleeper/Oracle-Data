select * from dict;

select * from dictionary;

SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

--입력 프로시저
CREATE OR REPLACE PROCEDURE INSERTSCORE
(PHAK IN SCORE.HAK%TYPE,
PNAME IN SCORE.NAME%TYPE,
PKOR IN SCORE.KOR%TYPE,
PENG IN SCORE.ENG%TYPE,
PMAT IN SCORE.MAT%TYPE)
IS
BEGIN
INSERT INTO SCORE(HAK,NAME,KOR,ENG,MAT)
VALUES (PHAK,PNAME,PKOR,PENG,PMAT);
COMMIT;
END;


EXEC INSERTSCORE('164', '오케나', 1, 1, 1);

--수정 프로시저
CREATE OR REPLACE PROCEDURE UPDATESCORE
(PHAK IN SCORE.HAK%TYPE,
PKOR IN SCORE.KOR%TYPE,
PENG IN SCORE.ENG%TYPE,
PMAT IN SCORE.MAT%TYPE)
IS
BEGIN
UPDATE SCORE SET KOR = PKOR, ENG = PENG, MAT = PMAT 
WHERE HAK = PHAK;
COMMIT;
END;

EXEC UPDATESCORE('111', 9, 9, 9);

--삭제 프로시저
CREATE OR REPLACE PROCEDURE DELETESCORE
(PHAK IN SCORE.HAK%TYPE)
IS
BEGIN
DELETE SCORE WHERE HAK = PHAK;
COMMIT;
END;


EXEC DELETESCORE('164');

--전체 출력
CREATE OR REPLACE PROCEDURE SELECTALLSCORE
(PRESULT OUT SYS_REFCURSOR)
IS
BEGIN
OPEN PRESULT FOR
SELECT HAK, NAME, KOR, ENG, MAT,
(KOR + ENG + MAT) TOT, (KOR + ENG + MAT) / 3 AVG,
RANK() OVER (ORDER BY (KOR + ENG + MAT) DESC) RANK
FROM SCORE ORDER BY HAK;
END;

--이름 출력
CREATE OR REPLACE PROCEDURE SELECTNAMESCORE
(PRESULT OUT SYS_REFCURSOR, PNAME IN VARCHAR2)
IS
BEGIN
OPEN PRESULT FOR
SELECT HAK, NAME, KOR, ENG, MAT,
(KOR + ENG + MAT) TOT, (KOR + ENG + MAT) / 3 AVG
FROM SCORE WHERE NAME LIKE PNAME||'%';
END;


--학번 검색
CREATE OR REPLACE PROCEDURE SELECTHAKSCORE
(PRESULT OUT SYS_REFCURSOR, PHAK IN VARCHAR2)
IS
BEGIN
OPEN PRESULT FOR
SELECT HAK, NAME, KOR, ENG, MAT,
(KOR + ENG + MAT) TOT, (KOR + ENG + MAT) / 3 AVG
FROM SCORE WHERE HAK = PHAK;
END;

SELECT * FROM USER_IND_COLUMNS;

SELECT * FROM USER_INDEXES;

CREATE INDEX SCOTT_IDX
ON EMP_TEMP2(ENAME DESC, EMPNO ASC);


SELECT * FROM EMP_TEMP2;

SELECT * FROM USER_IND_COLUMNS;

DROP INDEX SCOTT_IDX;

CREATE VIEW VW_EMP20
	AS (SELECT EMPNO, ENAME, JOB, DEPTNO
		FROM EMP
		WHERE DEPTNO = 20);
		
SELECT * FROM VW_EMP20;
		
SELECT * FROM USER_VIEWS;

SELECT VIEW_NAME, TEXT_LENGTH, TEXT FROM USER_VIEWS;

drop VIEW VW_EMP20;

CREATE TABLE TEST1
(ID NUMBER PRIMARY KEY, NAME VARCHAR2(10) NOT NULL);

CREATE TABLE TEST2
(ID NUMBER PRIMARY KEY,
BIRTH DATE NOT NULL,
CONSTRAINT TEST2_ID_FK FOREIGN KEY (ID)
REFERENCES TEST1(ID));

CREATE TABLE TEST3
(ID NUMBER PRIMARY KEY,
TEL VARCHAR2(20) NOT NULL,
CONSTRAINT TEST3_ID_FK FOREIGN KEY (ID)
REFERENCES TEST1(ID));

select * from test1 t1, test2 t2, test3 t3 where t1.id = t2.id and t1.id = t3.id;

SELECT ROWNUM, E.* FROM EMP E;

SELECT ROWNUM, E.* FROM EMP E ORDER BY SAL DESC;

SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E;

WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
SELECT ROWNUM, E.* FROM E;

SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E WHERE ROWNUM <= 3;

with e as (select * from EMP ORDER BY SAL DESC)
SELECT ROWNUM, E.* FROM E WHERE ROWNUM <= 3;

CREATE TABLE BASICDATA
(ID VARCHAR2(10) PRIMARY KEY,
PWD VARCHAR2(20) NOT NULL,
NAME VARCHAR2(20) NOT NULL);

--시스템 계정에서 주기
grant create database link to suzi;

CREATE DATABASE LINK link_test
CONNECT TO suzi IDENTIFIED BY "a123"
USING 
'(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)
(HOST=192.168.16.5)(PORT=1521))
(CONNECT_DATA=(SERVICE_NAME=XE)))';

select * from basicdata@link_test;

INSERT INTO SCORE@LINK_TEST VALUES('888', '시연바보', 0,0,0);

CREATE TABLE GUESTCUSTOM
(ID VARCHAR2(20) PRIMARY KEY, 
PW VARCHAR2(20), 
NAME VARCHAR2(10));

CREATE TABLE GUESTRECORD
(ID VARCHAR2(20) PRIMARY KEY,
G_CONTENT VARCHAR2(1000),
CREATED DATE,
CONSTRAINT GUEST_ID_FK FOREIGN KEY (ID)
REFERENCES GUESTCUSTOM(ID));


DESC USER_CONSTRAINTS;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP';


--writeInfo(?,?,?)
CREATE OR REPLACE PROCEDURE WRITEINFO
(ID IN GUESTCUSTOM.ID%TYPE,
PW IN GUESTCUSTOM.PW%TYPE,
NAME IN GUESTCUSTOM.NAME%TYPE)
IS
BEGIN
INSERT INTO GUESTCUSTOM
VALUES (ID, PW, NAME);
COMMIT;
END;

--방명록을 입력하고 엔터를 치면 날짜에서 오류가 남...
--이유를 모르겠음. 아마 한글 오류라고 생각됨.
--writeRecord(?,?,?)
CREATE OR REPLACE PROCEDURE WRITERECORD
(ID IN GUESTRECORD.ID%TYPE,
G_CONTENT IN GUESTRECORD.G_CONTENT%TYPE,
CREATED IN GUESTRECORD.CREATED%TYPE)
IS
BEGIN
INSERT INTO GUESTRECORD(ID, G_CONTENT, CREATED)
VALUES (ID, G_CONTENT, TO_DATE(CREATED));
COMMIT;
END;


--searchID(?, ?)
CREATE OR REPLACE PROCEDURE SEARCHID
(PRESULT OUT SYS_REFCURSOR,
ID IN GUESTCUSTOM.ID%TYPE)
IS
BEGIN
OPEN PRESULT FOR
SELECT C.ID, C.PW, C.NAME, R.G_CONTENT, R.CREATED
FROM GUESTCUSTOM C, GUESTRECORD R WHERE C.ID = SEARCHID.ID AND R.ID = SEARCHID.ID;
END;

--updateInfo(?, ?, ?)
CREATE OR REPLACE PROCEDURE UPDATEINFO
(ID IN GUESTCUSTOM.ID%TYPE,
PW IN GUESTCUSTOM.PW%TYPE,
NAME IN GUESTCUSTOM.NAME%TYPE)
IS
BEGIN
UPDATE GUESTCUSTOM C SET C.ID = UPDATEINFO.ID, C.PW = UPDATEINFO.PW, C.NAME = UPDATEINFO.NAME WHERE ID = UPDATEINFO.ID;
COMMIT;
END;

--updateRecord(?, ?, ?)
CREATE OR REPLACE PROCEDURE UPDATERECORD
(ID IN GUESTRECORD.ID%TYPE,
G_CONTENT IN GUESTRECORD.G_CONTENT%TYPE,
CREATED IN GUESTRECORD.CREATED%TYPE)
IS
BEGIN
UPDATE GUESTRECORD R SET R.ID = UPDATERECORD.ID, R.G_CONTENT = UPDATERECORD.G_CONTENT, R.CREATED = UPDATERECORD.CREATED WHERE ID = UPDATERECORD.ID;
COMMIT;
END;


--deleteData(?)
CREATE OR REPLACE PROCEDURE DELETEDATA
(ID IN GUESTCUSTOM.ID%TYPE)
IS
BEGIN
DELETE FROM GUESTRECORD WHERE GUESTRECORD.ID = DELETEDATA.ID;
DELETE FROM GUESTCUSTOM WHERE GUESTCUSTOM.ID = DELETEDATA.ID;
COMMIT;
END;



--printData(?)
CREATE OR REPLACE PROCEDURE PRINTDATA
(PRESULT OUT SYS_REFCURSOR)
IS
BEGIN
OPEN PRESULT FOR
SELECT C.ID, C.PW, C.NAME, R.G_CONTENT, R.CREATED
FROM GUESTCUSTOM C, GUESTRECORD R WHERE C.ID = R.ID;
END;

--로그인 검사 트리는 트리거로 안만드는 게 좋다는 결론이 나왔다.
--로그인 검사는 insert나 update 프로시저에서 하자.
--다만 하나 좋은 거 알게 된건 테이블이 2개가 있고 테이블1의 pk를 테이블2에서 fk로 참조할때 테이블 1을 만들면 자동으로 테이블2에도 테이터를 하나 만들게 하는 트리거를 만들자 . 당연히 같 id로
--아래 트리거는 drop하자
--내일은 insert,update 프로시저에서 중복 처리해보
CREATE OR REPLACE TRIGGER TRI_LOGIN
BEFORE UPDATE OF ID ON GUESTRECORD
FOR EACH ROW
DECLARE
ID_DUPLICATE EXCEPTION;
NID VARCHAR2(20);
BEGIN
SELECT ID INTO NID FROM GUESTCUSTOM WHERE ID = :NEW.ID;

RAISE ID_DUPLICATE;
EXCEPTION
WHEN ID_DUPLICATE THEN
RAISE_APPLICATION_ERROR(-20007, '동일한 아이디가 있습니다.');
END;



INSERT INTO GUESTCUSTOM(ID, PW, NAME) VALUES ('ingn', 'ADF', 'ASDF');

UPDATE GUESTRECORD SET G_CONTENT = 'DDSAFD' WHERE ID = 'ingn';


UPDATE GUESTRECORD SET ID = 'ingn1' WHERE ID = 'ingn';

UPDATE GUESTRECORD SET ID = 'ingn1' WHERE G_CONTENT = 'DDSAFD';





