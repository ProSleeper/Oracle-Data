--LEE 

SELECT * FROM CUSTOM;

SELECT USERNAME, RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;


SELECT * FROM CUSTOM;

SELECT ADDR1, COUNT(*), ROUND(AVG(POINT)) FROM CUSTOM GROUP BY ADDR1;

SELECT SEX, COUNT(*), ROUND(AVG(AGE)) FROM CUSTOM GROUP BY SEX; 

SELECT CASE SEX WHEN '1' THEN '남자' WHEN '0' THEN '여자' END GENDER, COUNT(*), ROUND(AVG(AGE)) FROM CUSTOM GROUP BY SEX;

SELECT CASE 컬럼명
	WHEN 1 THEN 100
	WHEN 2 THEN 200
	WHEN 3 THEN 300
	WHEN 4 THEN 400
	ELSE 500
END AS 별칭
FROM DUAL;
	
SELECT
CASE 컬럼명 WHEN 1 THEN 100 ELSE 0,
CASE 컬럼명 WHEN 2 THEN 200 ELSE 0,
CASE 컬럼명 WHEN 3 THEN 300 ELSE 0,
CASE 컬럼명 WHEN 4 THEN 400 ELSE 0,
FROM DUAL;
	
	
SELECT * FROM CUSTOM;

SELECT CASE ADDR1
WHEN '서울특별시' THEN '서울'
WHEN '경기도' THEN '경기'
WHEN '경상남도' THEN '경남'
END ADDR
FROM CUSTOM;


--JOIN문
--EQUIE JOIN(INNER JOIN)
--NON-EQUIE JOIN
--OUTER JOIN
--CROSS JOIN
--SELF JOIN

SELECT * FROM TAB;


SELECT * FROM CUSTOM;
SELECT * from COMPAny;
SELECT * FROM COMPANY WHERE USERID = 'nu7634';
SELECT * FROM CUSTOM WHERE USERNAME = '신동오';
SELECT * FROM POINT WHERE USERID = 'nu7634';
SELECT * FROM SALES WHERE USERID = 'nu7634';


--EQUIE JOIN(INNER JOIN)
SELECT A.USERID, USERNAME, AGE, ADDR1, B.USERID, COMPANY, PAY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID;

--이 방법이 표준이지만 지금은 둘다 가능하다.
SELECT A.USERID, USERNAME, AGE, ADDR1, B.USERID, COMPANY, PAY
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID ORDER BY AGE;

--'CUSTOM'에서 UserID, UserName을 검색하고 POINT 테이블에서 제품 구입, 로그인에 관계된 POINT점수(Product, Login)을 검색
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10 ORDER BY LOGIN;

SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN POINT B
ON A.USERID = B.USERID
WHERE LOGIN >= 10; -- AND LOGIN >= 10 ORDER BY LOGIN;

--OUTER JOIN(외부조인)

SELECT COUNT(*) FROM CUSTOM;	--459
SELECT COUNT(*) FROM COMPANY;	--464


SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A , COMPANY B
WHERE A.USERID = B.USERID(+)
ORDER BY B.COMPANY DESC;


SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A , COMPANY B
WHERE A.USERID(+) = B.USERID;
ORDER BY B.COMPANY DESC;


---------------------------------------------------------------------------
--현재 데이터의 수가 서로 다르므로 조인할때 어떤 것을 기준으로 할 것인지 정해주는 방법
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B
ON A.USERID = B.USERID
ORDER BY B.COMPANY DESC;


SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B
ON A.USERID(+) = B.USERID;
ORDER BY B.COMPANY DESC;



--CROSS JOIN(상호 조인)
-- 459*464 약 21만개
SELECT A.USERID, USERNAME, AGE, ADDR1, B.USERID, COMPANY, PAY
FROM CUSTOM A, COMPANY B;

SELECT A.USERID, USERNAME, AGE, ADDR1, B.USERID, COMPANY, PAY
FROM CUSTOM A CROSS JOIN COMPANY B;

SELECT A.USERID, USERNAME, AGE, ADDR1, B.USERID, COMPANY, PAY
FROM CUSTOM A CROSS JOIN COMPANY B WHERE A.USERID = B.USERID;	--이렇게 WHERE 조건을 주면 INNER JOIN이 된다.

--SELF JOIN
SELECT * FROM CUSTOM ORDER BY USERNAME;

SELECT DISTINCT A.* FROM CUSTOM A, CUSTOM B WHERE A.USERNAME = B.USERNAME AND A.USERID <> B.USERID ORDER BY A.USERNAME;


--'CUSTOM' 테이블에서 '제주도'에 살고 있는 사람 중에 동일한 이름을 갖는 행을 검색
SELECT A.*
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME
WHERE A.USERID <> B.USERID AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도';
	
	
SELECT A.* FROM CUSTOM A, CUSTOM B WHERE A.ADDR1 = '제주도' AND B.ADDR1 = '제주도' AND A.USERNAME = B.USERNAME AND  A.USERID <> B.USERID;
-- AND B.ADDR1 = '제주도') AND A.USERNAME = B.USERNAME ORDER BY A.USERNAME;


--3개 이상의 테이블
--CUSTOM: USERID, USERNAME
--COMPANY: COMPANY, DEPTH
--POINT: PRODUCT, LOGIN

	
SELECT M.USERID, M.USERNAME, C.COMPANY, C.DEPT, P.PRODUCT, P.LOGIN FROM
CUSTOM M, COMPANY C, POINT P WHERE M.USERID = C.USERID AND M.USERID = P.USERID;



SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--파생 테이블과 조인

SELECT * FROM SALES;

--아이디별로  판매횟수와 판매금액의 합 검색
SELECT USERID, COUNT(*) CNT, SUM(PRICE) 합 FROM SALES GROUP BY USERID HAVING SUM(PRICE) >= 2000000;


--INLINE-VIEW
SELECT A.USERID, USERNAME, ADDR1, HAP
FROM CUSTOM A ,(
SELECT USERID, SUM(PRICE) HAP FROM SALES
GROUP BY USERID HAVING SUM(PRICE) >= 1500000) B
WHERE A.USERID = B.USERID;


SELECT * FROM CUSTOM;

CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

CREATE TABLE SEOUL
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

CREATE TABLE KYUNG
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

SELECT * FROM TAB;

SELECT * FROM JEJU;
SELECT * FROM SEOUL;
SELECT * FROM KYUNG;

SELECT * FROM 
(
	SELECT * FROM JEJU
	UNION
	SELECT * FROM SEOUL
	UNION
	SELECT * FROM KYUNG
) ORDER BY USERID DESC;

--SUBQUERY(하위 쿼리)
--COMPANY 테이블에서 USERID, COMPANY, DEPT, PAY, 평균월급

SELECT * FROM COMPANY;

SELECT ROUND(AVG(PAY)) A_PAY FROM COMPANY;

SELECT USERID, COMPANY, DEPT PAY,
(
	SELECT ROUND(AVG(PAY)) A_PAY FROM COMPANY
) A_PAY
FROM COMPANY;


--CUSTOM 테이블에서 평균 나이보다 많은 사원의 정보 검색
SELECT * FROM CUSTOM;

SELECT ROUND(AVG(AGE)) FROM CUSTOM;

SELECT * FROM CUSTOM WHERE AGE>=(SELECT ROUND(AVG(AGE)) FROM CUSTOM);

--현대자동차 그룹에 근무하는 직원
SELECT * FROM COMPANY WHERE COMPANY='현대자동차 서비스';
SELECT * FROM COMPANY WHERE COMPANY LIKE '현대자동차 서비스';
SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차 서비스';

SELECT * FROM CUSTOM WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');
SELECT * FROM CUSTOM WHERE USERID NOT IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT A.* FROM CUSTOM A, COMPANY B WHERE A.USERID = B.USERID AND COMPANY LIKE '현대자동차%';

--4회 이상 판매 기록이 있는 고객들의 기본 정보를 검색

SELECT * FROM SALES;

--SELECT A.* FROM CUSTOM A, SALES B WHERE A.USERID = B.USERID AND  SELECT * FROM SALES WHERE USERID COUNT(B.USERID) >= 4;-- ORDER BY A.USERID ;


SELECT * FROM CUSTOM A WHERE (SELECT * FROM SALES S WHERE COUNT(A.USERID = S.USERID);-- ORDER BY A.USERID ;

--4회 이상 판매기록이 있는 고객
SELECT USERID, COUNT(*) CNT FROM SALES GROUP BY USERID HAVING COUNT(*) >=4; 

--하위 쿼리 방식
--4회 이상 판매 기록이 있는 고객의 기본 정보 출력(위의 코드를 그대로 넣어줬다. COUNT는 빼고
SELECT * FROM CUSTOM WHERE USERID IN(SELECT USERID FROM SALES GROUP BY USERID HAVING COUNT(*) >=4);


--4회 이상 판매 기록이 있는 고객의 기본 정보를 조인으로 출력 (INLINE_JOIN)
SELECT A.*, CNT 
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID HAVING COUNT(*) >=4)
B WHERE A.USERID = B.USERID;


--ANY(범위가 포함), ALL(범위가 미포함)
-- > ANY: 최소값보다 큰 데이터
-- < ANY: 최대값보다 작은 데이터
-- > ALL: 최대값보다 큰 데이터
-- < ALL: 최소값보다 작은 데이터

SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도' ORDER BY POINT;
--최소값 132, 최대값 269

--ANY의 사용법
SELECT * FROM CUSTOM WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT * FROM CUSTOM WHERE POINT > (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');

------------------------------------------------------------------------------------------

SELECT * FROM CUSTOM WHERE POINT < ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT * FROM CUSTOM WHERE POINT > (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');

------------------------------------------------------------------------------------------


--ALL의 사용법
SELECT * FROM CUSTOM WHERE POINT > ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT * FROM CUSTOM WHERE POINT > (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');

------------------------------------------------------------------------------------------

SELECT * FROM CUSTOM WHERE POINT < ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT * FROM CUSTOM WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT * FROM CUSTOM;

UPDATE CUSTOM SET POINT = 130 WHERE USERID = 'nu7634';
------------------------------------------------------------------------------------------

SELECT POINT FROM CUSTOM WHERE AGE >= 70;

SELECT * FROM CUSTOM
WHERE POINT > ANY(SELECT POINT FROM CUSTOM WHERE AGE >= 70); --하위쿼리의 결과가 없으면(못 찾으면) ANY는 상위 쿼리도 안나온다.


SELECT * FROM CUSTOM
WHERE POINT < ALL(SELECT POINT FROM CUSTOM WHERE AGE >= 70); --하위쿼리의 결과가 없어도 ALL은 모든 데이터가 출력된다.

------------------------------------------------------------------------------------------

SELECT * FROM CUSTOM
WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT * FROM CUSTOM
WHERE USERID = ANY(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--위 두개가 같은 출력
------------------------------------------------------------------------------------------

SELECT * FROM CUSTOM
WHERE USERID NOT IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT * FROM CUSTOM
WHERE USERID <> ALL(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');
--위 두개가 같은 출력
------------------------------------------------------------------------------------------

--하위쿼리를 이용한 방법(IN 이후 부분만 따로도 실행을 할 수 없다.)
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%'); --O

--상관쿼리(EXISTS 이후 부분을 따로는 실행을 할 수 없다.)
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS
(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');

(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%'); --X

------------------------------------------------------------------------------------------

SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' ORDER BY POINT) A
WHERE A.AGE <= 20;

SELECT * FROM TAB;

-----------------------------------------------------------------------------------------------
--하위쿼리(독자적 실행 O)
SELECT USERID,USERNAME,ADDR1,SCHOL FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');
--상관쿼리(독자적 실행 X)
--EXISTS : 서브쿼리에 결과값이 하나 이상 존재하면 조건식 모두 TRUE, 존재하지 않으면 모두 FALSE
--자주사용하지는 않음. 특정 서브쿼리 결과값의 존재유무를 통해 메인쿼리의 데이터 노출 여부를 결정해야 할때 사용
SELECT USERID,USERNAME,ADDR1,SCHOL FROM CUSTOM
WHERE EXISTS 
(SELECT * FROM COMPANY WHERE USERID =CUSTOM.USERID AND COMPANY LIKE '현대자동차%');

-----------------------------------------------------------------------------------------
SELECT * FROM CUSTOM WHERE ADDR1='경기도' AND AGE <=20;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1='경기도') A
WHERE AGE <=20;

--DML(INSERT,UPDATE,DELETE)


create table 사원
(	사원번호 number(10),
	사원명 varchar2(10),
	부서번호 number(2),
	직급 varchar2(10),
	우편번호 char(7),
	주소 varchar2(50),
	전화번호 char(15),
	급여 number(5),
	커미션 number(5),
	입사일 date,
	성별 char(4),
	사수번호 number(10)
);

--insert into 사원 values(2001,'이순신',10,'부장','125-365','서울 용산구','02-985-1254',3500,100,'1980-12-01','남자',null);
--insert into 사원 values(2002,'홍길동',10,'대리','354-865','서울 강남구','02-865-1254',4000,'','2000-01-25','남자',2004);
--insert into 사원 values(2003,'성유리',20,'사원','587-456','부산 해운대구','051-256-9874',2500,100,'2002-05-24','여자',2002);
--insert into 사원 values(2004,'옥주현',30,'과장','987-452','서울 강남구','02-33-6589',5000,'','1997-03-22','여자',2001);
--insert into 사원 values(2005,'길건',10,'대리','123-322','서울 성동구','02-888-9564',3000,100,'1999-07-15','여자',2004);
--insert into 사원 values(2006,'한지혜',20,'사원','154-762','서울 송파구','02-3369-9874',2000,'','2003-05-22','여자',2005);
--insert into 사원 values(2007,'박솔미',30,'대리','367-985','서울 영등포구','02-451-2563',3000,100,'2006-01-25','여자',2004);
--insert into 사원 values(2008,'이효리',40,'사원','552-126','서울 중구','02-447-3256',2000,'','2001-02-02','여자',2007);

COMMIT;

SELECT * FROM 사원;
DESC 사원;

--CUSTOM 테이블에 INSERT 시키는 프로시져

--CUSTOM 테이블에 UPDATE 시키는 프로시져

--CUSTOM 테이블에 DELETE 시키는 프로시져

SELECT * FROM CUSTOM;
DESC CUSTOM;


--CURSOR
--명시적 커서 오픈
CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS
	CURSOR CUR_DEPTNO
	IS
	SELECT 부서번호, 사원명, 직급, 급여 FROM 사원
	WHERE 부서번호 = I_DEPTNO;
V_DEPTNO 사원.부서번호%TYPE;
V_SANAME 사원.사원명%TYPE;
V_JIK 사원.직급%TYPE;
V_SAL 사원.급여%TYPE;
BEGIN

OPEN CUR_DEPTNO;

DBMS_OUTPUT.PUT_LINE('부서번호 사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE('-------------------------');

LOOP
FETCH CUR_DEPTNO INTO V_DEPTNO, V_SANAME, V_JIK, V_SAL;
EXIT WHEN CUR_DEPTNO%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_DEPTNO) || '  ' ||
V_SANAME || '  ' || V_JIK || '  ' || TO_CHAR(V_SAL));
END LOOP;
DBMS_OUTPUT.PUT_LINE('전체데이터의 갯수: ' || TO_CHAR(CUR_DEPTNO%ROWCOUNT));
CLOSE CUR_DEPTNO;
END;


--묵시적 커서 오픈
CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS
	CURSOR CUR_DEPTNO
	IS
	SELECT 부서번호, 사원명, 직급, 급여 FROM 사원
	WHERE 부서번호 = I_DEPTNO;
V_CNT NUMBER;
BEGIN


DBMS_OUTPUT.PUT_LINE('부서번호 사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE('-------------------------');

FOR CURDEPT IN CUR_DEPTNO LOOP

DBMS_OUTPUT.PUT_LINE(TO_CHAR(CURDEPT.부서번호) || '  ' ||
CURDEPT.사원명 || '  ' || CURDEPT.직급 || '  ' || TO_CHAR(CURDEPT.급여));
V_CNT := CUR_DEPTNO%ROWCOUNT;
END LOOP;
DBMS_OUTPUT.PUT_LINE('전체데이터의 갯수: ' || TO_CHAR(V_CNT));
END;


--사원번호를 입력시 사원 이름과 구입한 제품명
CREATE OR REPLACE PROCEDURE P_JEPUM
(V_USERID IN VARCHAR2)
IS
V_CNT NUMBER;
CURSOR SA_CUR
IS
SELECT C.USERID, C.USERNAME, S.PRODUCTNAME FROM CUSTOM C, SALES S
WHERE C.USERID = S.USERID AND S.USERID = V_USERID;
BEGIN
DBMS_OUTPUT.PUT_LINE('아이디  이름  제품');
DBMS_OUTPUT.PUT_LINE('------------------');

FOR SA_REC IN SA_CUR LOOP

DBMS_OUTPUT.PUT_LINE(SA_REC.USERID || '  ' || SA_REC.USERNAME || '  ' || SA_REC.PRODUCTNAME);
END LOOP;
DBMS_OUTPUT.PUT_LINE('전체데이터의 갯수: ' || TO_CHAR(V_CNT));
END;


--PACKAGE
CREATE OR REPLACE PACKAGE SAWON_PACK
IS
PROCEDURE SANO_OUT;
PROCEDURE SANAME_OUT;
PROCEDURE BUNO_OUT;
END;

CREATE OR REPLACE PACKAGE BODY SAWON_PACK
IS
	CURSOR SW_CUR
	IS
	SELECT * FROM 사원;
PROCEDURE SANO_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원번호');
DBMS_OUTPUT.PUT_LINE('------');
FOR SW IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW.사원번호);
END LOOP;
END;

PROCEDURE SANAME_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원명');
DBMS_OUTPUT.PUT_LINE('------');
FOR SW IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW.사원명);
END LOOP;
END;


PROCEDURE BUNO_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호');
DBMS_OUTPUT.PUT_LINE('--------');
FOR SW IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW.부서번호);
END LOOP;
END;
END;

EXEC SAWON_PACK.BUNO_OUT;

--TRIGGER
CREATE TABLE HAKSANG
(HAKBUN VARCHAR2(10), NAME VARCHAR2(10));

CREATE TABLE MEMO
(NO NUMBER, BIGO VARCHAR2(200));

CREATE SEQUENCE SE100
START WITH 1
INCREMENT BY 1
MAXVALUE 100
NOCYCLE
NOCACHE;

--AFTER TRIGGER(INSERT TRIGGER)
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, '행이 INSERT 되었습니다.');
END;

INSERT INTO HAKSANG VALUES(111, 'SUZI');

SELECT * FROM MEMO;

CREATE OR REPLACE TRIGGER TRI_HAKSANG_UP

--트리거 변경
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, :NEW.NAME || '행이 INSERT 되었습니다.');
END;

--입력한 데이터 다른 테이블에 복사하기
CREATE TABLE COPY_HAKSANG
(HAKBUN VARCHAR2(10), NAME VARCHAR2(10));

CREATE OR REPLACE TRIGGER TRI_COPY_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO COPY_HAKSANG VALUES(:NEW.HAKBUN, :NEW.NAME);
END;

INSERT INTO HAKSANG VALUES(333, 'INSUN');

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;
SELECT * FROM COPY_HAKSANG;

CREATE OR REPLACE TRIGGER TRI_HAKSANG_UP
AFTER UPDATE OF NAME
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, :OLD.NAME || '행이 '||
:NEW.NAME || '으로 UPDATE 되었습니다.');
END;

UPDATE HAKSANG SET NAME = 'SHIN' WHERE HAKBUN = 111;

SELECT * FROM MEMO;

CREATE OR REPLACE TRIGGER TRI_HAKSANG_DEL
AFTER DELETE
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, :OLD.NAME || '행이 DELETE 됨');
INSERT INTO COPY_HAKSANG VALUES (:OLD.HAKBUN, :OLD.NAME);
END;

DELETE HAKSANG WHERE HAKBUN = 111;

CREATE TABLE INSA
(EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10), JIK VARCHAR2(10), SAL NUMBER);


CREATE OR REPLACE TRIGGER TRI_INSA
BEFORE INSERT OR UPDATE OR DELETE ON LEE.INSA
DECLARE
IMPOSSIBLE_TIME EXCEPTION;
BEGIN
IF TO_CHAR(SYSDATE, 'DAY') IN ('토요일', '일요일') OR
TO_CHAR(SYSDATE, 'HH24') < 12 OR TO_CHAR(SYSDATE, 'HH24') > 17 THEN
RAISE IMPOSSIBLE_TIME;
END IF;
EXCEPTION
WHEN IMPOSSIBLE_TIME THEN
RAISE_APPLICATION_ERROR(-20007, '월 ~ 금요일 12:00 부터 17:00 까지만 DML 작업이 가능합니다!');
END;

INSERT INTO INSA VALUES(1, '배수지', '과장', 5000);


CREATE TABLE MEMBER
(ID NUMBER(3) PRIMARY KEY, NAME VARCHAR2(10), JUBUN VARCHAR2(13));

--DROP TABLE MEMBER PURGE;

CREATE OR REPLACE TRIGGER TRI_MEMBER_JUBUN
BEFORE INSERT OR UPDATE OF JUBUN ON LEE.MEMBER
FOR EACH ROW
DECLARE
A NUMBER;B NUMBER;C NUMBER;D NUMBER;E NUMBER;
F NUMBER;G NUMBER;H NUMBER;I NUMBER;J NUMBER;
K NUMBER;L NUMBER;M NUMBER;

CK NUMBER;

JUBUNFAIL EXCEPTION;
BEGIN
A := SUBSTR(:NEW.JUBUN, 1, 1);
B := SUBSTR(:NEW.JUBUN, 2, 1);
C := SUBSTR(:NEW.JUBUN, 3, 1);
D := SUBSTR(:NEW.JUBUN, 4, 1);
E := SUBSTR(:NEW.JUBUN, 5, 1);
F := SUBSTR(:NEW.JUBUN, 6, 1);
G := SUBSTR(:NEW.JUBUN, 7, 1);
H := SUBSTR(:NEW.JUBUN, 8, 1);
I := SUBSTR(:NEW.JUBUN, 9, 1);
J := SUBSTR(:NEW.JUBUN, 10, 1);
K := SUBSTR(:NEW.JUBUN, 11, 1);
L := SUBSTR(:NEW.JUBUN, 12, 1);
M := SUBSTR(:NEW.JUBUN, 13, 1);

CK := (A * 2) + (B * 3) + (C * 4) + (D * 5) + (E * 6) + (F * 7) + (G * 8) + 
(H * 9) + (I * 2) + (J * 3) + (K * 4) + (L * 5);

CK := MOD(CK, 11);
CK := 11 - CK;
CK := MOD(CK, 10);


IF M != CK THEN
RAISE JUBUNFAIL;
END IF;
EXCEPTION
WHEN JUBUNFAIL THEN
RAISE_APPLICATION_ERROR(-20001, '주민번호가 틀립니다!!');
END;

INSERT INTO MEMBER VALUES(1, '김영운', '8811041167811');

SELECT * FROM MEMBER;

DELETE FROM MEMBER WHERE ID = 1;

SELECT * FROM TAB;

DESC MEMBER;












