DECLARE
TYPE FIRSTTYPE IS RECORD
(
	A 사원.사원명%TYPE , B 사원.직급%TYPE, C 사원.급여%TYPE);
	CUS FIRSTTYPE;
BEGIN
	SELECT 사원명, 직급, 급여 INTO CUS FROM 사원 WHERE 사원번호 = 2001;

DBMS_OUTPUT.PUT_LINE('사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE('-----------------');
DBMS_OUTPUT.PUT_LINE(CUS.A || '  ' || CUS.B || '  ' || TO_CHAR(CUS.C));
DBMS_OUTPUT.PUT_LINE('질의한 사용자: '||USER||'입니다.');
DBMS_OUTPUT.PUT_LINE('질의한 시간: '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS'));

END;

DECLARE	--정의
SAWON_RECORD 사원%ROWTYPE;	
BEGIN	-- 실행
SELECT * INTO SAWON_RECORD FROM 사원 WHERE 사원번호 = 2001;
DBMS_OUTPUT.PUT_LINE('사원번호: ' || SAWON_RECORD.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명: ' || SAWON_RECORD.사원명);
DBMS_OUTPUT.PUT_LINE('주소: ' || SAWON_RECORD.주소);
DBMS_OUTPUT.PUT_LINE('급여: ' || SAWON_RECORD.급여);
END;


DECLARE
TYPE NAME_TYPE IS TABLE OF 사원.사원명%TYPE
INDEX BY BINARY_INTEGER;
TYPE JIK_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

SANAME_COL NAME_TYPE;
SAJIK_COL JIK_TYPE;

I BINARY_INTEGER := 0;
BEGIN
FOR K IN (SELECT 사원명, 직급 FROM 사원) LOOP
I := I + 1;
SANAME_COL(I) := K.사원명;
SAJIK_COL(I) := K.직급;
END LOOP;

FOR J IN 1..I LOOP
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J), 12)||RPAD(SAJIK_COL(J), 9));
END LOOP;
END;

CREATE OR REPLACE PROCEDURE CHANGE_PAY	--약간 함수 느낌
(V_SANO IN NUMBER, V_NEW_PAY IN NUMBER)	--매개변수
IS
BEGIN
UPDATE 사원 SET 급여 = V_NEW_PAY WHERE 사원번호 = V_SANO;
COMMIT;
END CHANGE_PAY;

CREATE OR REPLACE FUNCTION F_TAX
(V_SANO NUMBER)
RETURN NUMBER
IS
V_TAX NUMBER;
BEGIN
SELECT ((급여 * 12) + NVL(커미션, 0)) * 0.05 INTO V_TAX
FROM 사원 WHERE 사원번호 = V_SANO;

RETURN V_TAX;
END F_TAX;

SELECT 사원번호, 사원명, 직급, 커미션, F_TAX(2001) AS TAX
FROM 사원 WHERE 사원번호 = 2001;


CREATE OR REPLACE PROCEDURE P_OUTEX
(V_SANO IN 사원.사원번호%TYPE,
V_SANAME OUT 사원.사원명%TYPE,
V_PAY OUT 사원.급여%TYPE,
V_COMM OUT 사원.커미션%TYPE)
IS
BEGIN
SELECT 사원명, 급여, 커미션 INTO V_SANAME, V_PAY, V_COMM
FROM 사원 WHERE 사원번호 = V_SANO;
END P_OUTEX;

VARIABLE NAME VARCHAR2(10)
VARIABLE PAY NUMBER;
VARIABLE COMM NUMBER;

EXEC P_OUTEX(2001, :NAME, :PAY, :COMM);

SELECT :NAME, :PAY, :COMM FROM DUAL;

CREATE OR REPLACE PROCEDURE ADD_ONE
(V_TEL IN OUT VARCHAR2)
IS
BEGIN
V_TEL := SUBSTR(V_TEL, 1, 3)||'-'||SUBSTR(V_TEL, 4);
END;

VARIABLE TEL VARCHAR2(15);
EXEC :TEL := '12345678';

EXEC ADD_ONE(:TEL);
PRINT TEL;

CREATE OR REPLACE PROCEDURE P_GOJUTOT
(V_GNO IN VARCHAR2)
IS
TOT NUMBER;
BEGIN
SELECT COUNT(*) INTO TOT FROM SALES
WHERE USERID = V_GNO
GROUP BY USERID;

DBMS_OUTPUT.PUT_LINE(V_GNO||'번 고객님의 총 주문 횟수는 '|| TO_CHAR(TOT) || '번 입니다.');
END;

EXEC P_GOJUTOT('og6675');

CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS
A NUMBER := 0;
B NUMBER(12, 2) := 0;
C NUMBER := 0;
BEGIN
SELECT SUM(PAY), AVG(PAY), COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT = JIK;
DBMS_OUTPUT.PUT_LINE('급여총액: '||A||'원');
DBMS_OUTPUT.PUT_LINE('평균월급: '||B||'원');
DBMS_OUTPUT.PUT_LINE('인원수: '||C||'명');
END;

EXEC SEARCHJIK('과장');

CREATE TABLE TEST
(A NUMBER(10),
B NUMBER(10),
C DATE DEFAULT SYSDATE);


CREATE OR REPLACE PROCEDURE P_EX
(A IN NUMBER, B IN NUMBER)
IS
BEGIN
INSERT INTO TEST (A, B) VALUES (A, B);
COMMIT;
END;

EXEC P_EX(20, 30);

CREATE OR REPLACE PROCEDURE P_UP
(A_C NUMBER, B_C NUMBER)
IS
BEGIN
UPDATE TEST SET B = B_C WHERE A = A_C;
COMMIT;
END;

EXEC P_UP(10, 100);

CREATE OR REPLACE PROCEDURE P_DE
(A_C NUMBER)
IS
BEGIN
DELETE TEST WHERE A=A_C;
COMMIT;
END;

--CUSTOM 테이블에 INSERT 시키는 프로시져
CREATE OR REPLACE PROCEDURE CUS_IN
(USERID IN NUMBER, B IN NUMBER)
IS
BEGIN
INSERT INTO TEST (A, B) VALUES (A, B);
COMMIT;
END;

CREATE OR REPLACE PROCEDURE CUS_INTEST
(CUSTOM_RECORD CUSTOM%ROWTYPE)
IS
BEGIN
FETCH CUSTOM_RECORD INTO CUSTOM;
COMMIT;
END;







--CUSTOM 테이블에 UPDATE 시키는 프로시져
CREATE OR REPLACE PROCEDURE CUS_UP
--CUSTOM 테이블에 DELETE 시키는 프로시져
CREATE OR REPLACE PROCEDURE CUS_DEL
SELECT * FROM CUSTOM;
DESC CUSTOM;



CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2,B VARCHAR2, C VARCHAR2,D NUMBER,
E VARCHAR2,F VARCHAR2,G VARCHAR2,H VARCHAR2,
I VARCHAR2,J VARCHAR2,K VARCHAR2, L VARCHAR2,
M NUMBER,N VARCHAR2)
IS
BEGIN
INSERT INTO CUSTOM VALUES (A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;



CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2)
IS
BEGIN
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;


EXEC CUS_IN('S1111', '신동오', '770322-1291769',	24,	'1', '641-320',	'경상남도',	'창원시', '정동', '602-3577', '회사원', '기타', 130, SYSDATE);

CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2)
IS
BEGIN
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;


SELECT * FROM CUSTOM WHERE USERID = 'S1111';



CREATE OR REPLACE FUNCTION F_CUBVOL
(GILI NUMBER, POK NUMBER, NOPI NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI := GILI * POK * NOPI;
RETURN BUPI;
END;

SELECT F_CUBVOL(4, 7, 8) BUPI FROM DUAL;

CREATE OR REPLACE FUNCTION F_NAME
(NAME IN VARCHAR2)
RETURN VARCHAR2
IS
NA VARCHAR2(8);
BEGIN
NA := SUBSTR(NAME, -2);
RETURN NA;
END;

SELECT F_NAME('김이나박') NAME FROM DUAL;
SELECT F_NAME(USERNAME) FROM CUSTOM WHERE ADDR1 = '제주도';


COL NAME FORMAT A8;

SELECT
FLOOR(MONTHS_BETWEEN(SYSDATE, '2002-06-01')/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, '2002-06-01'), 12)) || '개월'
FROM DUAL;

CREATE OR REPLACE FUNCTION F_SDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE := FLOOR(MONTHS_BETWEEN(SYSDATE, V_DATE)/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, '2002-06-01'), 12)) || '개월';
RETURN GUNDATE;
END;

SELECT USERNAME, REGDATE, F_SDAY(REGDATE) GUNDATE FROM CUSTOM WHERE ADDR1 = '제주도';

CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(2);
BEGIN
GENDER := SUBSTR(V_JUMIN, 8, 1);
IF GENDER IN('1', '3') THEN
GENDER := '남';
ELSE
GENDER := '여';
END IF;
RETURN GENDER;
END;


SELECT USERNAME, JUMIN, F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE ADDR1 = '제주도';


CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
RESULT := 'A';
ELSIF V_PAY > 2000000 THEN
RESULT := 'B';
ELSIF V_PAY > 1500000 THEN
RESULT := 'C';
ELSIF V_PAY > 1000000 THEN
RESULT := 'D';
ELSE
RESULT := 'E';
END IF;
RETURN RESULT;
END;

 SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
 FROM COMPANY WHERE USERID = 'XA9776';

CREATE TABLE TEST2
(NO NUMBER, NAME VARCHAR2(9) DEFAULT '홍길동');

DECLARE
V_COUNT NUMBER(2) := 1;
BEGIN
LOOP
INSERT INTO TEST2(NO) VALUES(V_COUNT);
V_COUNT := V_COUNT + 1;
EXIT WHEN V_COUNT > 10;
END LOOP;
DBMS_OUTPUT.PUT_LINE('데이터 입력 완료');
END;

SELECT * FROM TEST2;


--DO WHILE
CREATE OR REPLACE PROCEDURE P_FOR
IS
BEGIN
FOR I IN 11..30 LOOP
INSERT INTO TEST2(NO) VALUES(I);
END LOOP;
COMMIT;
END;

EXEC P_FOR;

--WHILE
CREATE OR REPLACE PROCEDURE P_WHILE
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
END LOOP;
DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) || '부터' || TO_CHAR(V_END) || '까지의 합은' || TO_CHAR(TOT) || '입니다.');
END;

EXEC P_WHILE(1, 10);

CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = '2001';
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다.');
WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다.');
WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타에러 입니다.');
END;

--사용자 정의 에러
CREATE OR REPLACE PROCEDURE PAY_VALIDATE
(V_SANO 사원.사원번호%TYPE)
IS
NOT_ENOUGH_PAY EXCEPTION;
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = V_SANO;

IF SW_REC.급여 >= 3000 THEN
DBMS_OUTPUT.PUT_LINE('급여가 3000 이상 적당함');
ELSIF SW_REC.급여 < 3000 THEN
RAISE NOT_ENOUGH_PAY;
ELSE
DBMS_OUTPUT.PUT_LINE('급여가 이상함');
END IF;
EXCEPTION
WHEN NOT_ENOUGH_PAY THEN
RAISE_APPLICATION_ERROR(-20001, '급여가 충분하지 못함');
END;

--사용자 정의 에러
EXEC PAY_VALIDATE(2003);


CREATE TABLE EMP_RECORD FROM EMP WHERE 1 <> 1;

CREATE TABLE TEST2
(NO NUMBER, NAME VARCHAR2(9) DEFAULT '홍길동');




