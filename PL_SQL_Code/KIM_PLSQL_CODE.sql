select * from tab;

SELECT * from PERSONNEL;

/*
SQL (Structured Query Language : 구조화된 질의 언어)
ANSI 표준

1. query
   select data검색어

2. dml(data maipulation language) 데이터 조작
    insert, update, delete
    
3. ddl(data difinition language) 데이터 정의
    create, alter, drop, rename
    
4. tcl(transaction control language) 트랜잭션 제어
    commit, rollback
    
5. dcl(data control language) 데이터 제어
    grant, revoke
*/
 
select * from personnel;

select pno, job, pay from personnel;

SELECT JOB FROM PERSONNEL;

SELECT DISTINCT JOB FROM PERSONNEL;

SELECT * FROM PERSONNEL
ORDER BY STARTDATE;


--별칭
SELECT PNO, PNAME, PAY, PAY+1000 AS BONUS FROM PERSONNEL;
SELECT PNO, PNAME, PAY, PAY+1000 BONUS FROM PERSONNEL;
SELECT PNO, PNAME, PAY, PAY+1000 보너스 FROM PERSONNEL;
SELECT PNO, PNAME, PAY, PAY+1000 "B O N U S" FROM PERSONNEL;

SELECT PNO 번호, PNAME AS 이름,PAY 월급,PAY + 1000 AS 보너스 FROM PERSONNEL;


SELECT PNO, PNAME, PAY, PAY+1000 AS 보너스 FROM PERSONNEL
ORDER BY 보너스;

SELECT PNO, PNAME, PAY, PAY+1000 AS 보너스 FROM PERSONNEL
ORDER BY PAY+1000;

SELECT PNO, PNAME, PAY, PAY+1000 AS 보너스 FROM PERSONNEL
ORDER BY 4 DESC;

SELECT * FROM PERSONNEL
ORDER BY 4 DESC;

SELECT DNO,PNO,PNAME FROM PERSONNEL
ORDER BY DNO,PNO DESC;


--부서번호는 오름차순, 사원번호는 내림차순 정렬
SELECT * FROM PERSONNEL
ORDER BY DNO, PNO DESC;
--뭘 따라가는거지??


--NULL
SELECT MANAGER FROM PERSONNEL
ORDER BY MANAGER DESC;

--사원의 급여와 연봉을 출력하시오
SELECT PNO,PAY,PAY*12 AS SALARY FROM PERSONNEL
ORDER BY PNO;

SELECT PNAME ||' '|| PNO FROM PERSONNEL;

SELECT * FROM PERSONNEL;


SELECT PNO,PNAME,PAY,NVL(BONUS, 0), (PAY*12) + NVL(BONUS, 0) SALARY FROM PERSONNEL;

--조건절(WHERE)
SELECT * FROM PERSONNEL;

SELECT PNO, PNAME, JOB FROM PERSONNEL
WHERE JOB = 'SALESMAN';


SELECT PNO, PNAME, JOB FROM PERSONNEL
WHERE JOB = 'salesman';

--연산자
--=, >, >=, <=, <, <>(같지 않다.)


--급여가 1600인 사원

SELECT * FROM PERSONNEL
WHERE PAY = 1600;

--사원번호가 1116인 사원
SELECT * FROM PERSONNEL
WHERE PNO = '1116';

--사원 급여가 2000이하인 사원
SELECT * FROM PERSONNEL
WHERE PAY <= 2000;

--90년 12월 17일 입사 사원
SELECT * FROM PERSONNEL
WHERE STARTDATE = '1990-12-17';

--업무가 CLERK인 사원
SELECT * FROM PERSONNEL
WHERE JOB = 'CLERK';

--이름이 JAMES인 사원
SELECT * FROM PERSONNEL WHERE PNAME = 'JAMES';

--논리 연산자
--AND, OR, NOT(!)

--부서번호가 10번이고 급여가 3000이상인 사원
SELECT * FROM PERSONNEL WHERE DNO = 10 AND PAY >= 3000;

--직업이 SALESMAN이고 90년 이후 입사 직원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' AND STARTDATE >= '1990-12-31';

--91년 9월 입사직원
SELECT * FROM PERSONNEL WHERE STARTDATE >= '1991-9-1' AND STARTDATE <= '1991-9-30';

--날짜가 어떤 형식으로 되어 있는 지 보여줌
SELECT * FROM NLS_SESSION_PARAMETERS;

--부서번호가 10번이거나(or) 급여가 3000이상인 사원
SELECT * FROM PERSONNEL WHERE DNO = 10 OR PAY >= 3000;

--직업이 MANAGE 이거나(or) 90년 이전에 입사한 직원
SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER' OR STARTDATE < '1990-1-1';

--NOT
--업무가 SALESMAN, CLERK인 직원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' OR JOB = 'CLERK';

--업무가 SALESMAN, CLERK이 아닌 직원
SELECT * FROM PERSONNEL WHERE JOB <> 'SALESMAN' AND JOB <> 'CLERK';

--IN 문자열 연산자
SELECT * FROM PERSONNEL WHERE JOB IN('SALESMAN', 'CLERK');

SELECT * FROM PERSONNEL WHERE JOB NOT IN('SALESMAN', 'CLERK');

SELECT * FROM PERSONNEL WHERE NOT JOB IN('SALESMAN', 'CLERK');

--문자열 연산자
--BETWEEN A AND BACKUP

--급여가 1000에서 2000인 사원

SELECT * FROM PERSONNEL WHERE PAY >= 1000 AND PAY <= 2000;

--에러
SELECT * FROM PERSONNEL WHERE PAY BETWEEN 2000 AND 1000;

SELECT * FROM PERSONNEL WHERE STARTDATE BETWEEN '1991-09-01' AND '1991-09-30';

--부서번호가 20과 30사이가 아닌 사원을 찾으시오
--------------------------------------------------------------
--IN 은 20번과 30번만 찾는다
SELECT * FROM PERSONNEL WHERE DNO NOT IN (20, 30);

--BETWEEN은 20~30번 사이의 값을 모두 찾는다.
SELECT * FROM PERSONNEL WHERE NOT DNO BETWEEN 20 AND 30;
--------------------------------------------------------------

--이름이 A로 시작되는 사원
SELECT * FROM PERSONNEL WHERE PNAME LIKE 'A%';

--사원번호가 111_ 로 시작
SELECT * FROM PERSONNEL WHERE PNO LIKE '111_'; --_(언더바)는 정확히 한자리를 의미한다.

--사원번호가 111_ 로 시작
SELECT * FROM PERSONNEL WHERE PNO LIKE '111_%'; --%는 4자리 이상을 의미

SELECT * FROM PERSONNEL WHERE PNO LIKE '1__1';

--90년도에 입사한 사원
SELECT * FROM PERSONNEL WHERE STARTDATE LIKE '90%';

INSERT INTO PERSONNEL
VALUES(2000, 'HELLO_KIM','SALESMAN', 1116, '2022-07-04', 5000, '', 20);

INSERT INTO PERSONNEL
VALUES(2001, 'HELLOAKIM','SALESMAN', 1116, '2022-07-04', 5000, '', 20);



SELECT * FROM PERSONNEL;

--O_K 를 포함한 이름 검색

SELECT * FROM PERSONNEL WHERE PNAME LIKE '%O_K%';

SELECT * FROM PERSONNEL WHERE PNAME LIKE '%O\_K%' ESCAPE '\'; --_(언더바)를 문자로 사용하고 싶을 때는 \를 붙여주고 ESCAPE로 '\'을 빼준다.

--NULL
SELECT * FROM PERSONNEL
WHERE MANAGER = NULL; --X(MS-SQL에서는 된다.)

SELECT * FROM PERSONNEL
WHERE MANAGER = 'NULL'; --X

SELECT * FROM PERSONNEL
WHERE MANAGER IS NULL;

SELECT * FROM PERSONNEL
WHERE MANAGER IS NOT NULL;

--우선순위
--업무가 MANAGER이고 급여가 1500이상인 사원
--또는 업무가 SALESMAN인 사원
SELECT * FROM PERSONNEL WHERE (JOB = 'MANAGER' AND PAY >= 1500) OR JOB = 'SALESMAN' ORDER BY JOB;

SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER' AND (PAY >= 1500 OR JOB = 'SALESMAN') ORDER BY JOB;

--업무가 PRESIDENT 또는 SALESMAN 이고 급여가 1500이상인 사원
SELECT * FROM PERSONNEL WHERE (JOB = 'PRESIDENT' OR JOB = 'SALESMAN') AND PAY >= 1500 ORDER BY JOB;
SELECT * FROM PERSONNEL WHERE JOB IN ('PRESIDENT', 'SALESMAN') AND PAY >=1500;

DELETE FROM PERSONNEL WHERE PNAME LIKE 'HELLO%';

SELECT * FROM PERSONNEL;

--함수
--숫자함수
--ROUND(반올림)
SELECT ROUND(45.275,1) FROM DUAL;

SELECT ROUND(45.275,1) FROM PERSONNEL;

SELECT * FROM DUAL;

--  1  2  3  4  .  5  6  7 
-- -4 -3 -2 -1  0  1  2  3 (소수점을 판단할때 인덱스) 

SELECT ROUND(45.245, 1) FROM DUAL;
SELECT ROUND(45.245, -1) FROM DUAL;
SELECT ROUND(45.545, 0) FROM DUAL; --소수점 첫번째 자리에서 반올림해서 정수만 보여줌
SELECT ROUND(45.245) FROM DUAL; -- 적지 않으면 정수만 표현하지만 실제로는 소수점 첫째자리에서 반올림한다.


SELECT PNO, PNAME, PAY, ROUND(PAY, -2) PAY1 FROM PERSONNEL;

--TRUNC(절삭)(해당 자리수에서 무조건 버린다.)
SELECT TRUNC(45.245, 2) FROM DUAL;
SELECT TRUNC(45.245, -1) FROM DUAL;


SELECT PNO, PNAME, PAY, TRUNC(PAY, -2) PAY1 FROM PERSONNEL;

--CEIL / FLOOR (올림/내림) : 정수만 반환함
SELECT CEIL(461.21) FROM DUAL; --462  무조건 내림

SELECT FLOOR(461.91) FROM DUAL; --46\1  무조건 올림

--MOD(나머지)
SELECT MOD(10, 3) FROM DUAL;

--ABS(절대값)
SELECT ABS(-123) FROM DUAL;

--SIGN(양수: 1, 음수: -1, 영:0);
SELECT SIGN(100-20), SIGN(100-102), SIGN(100-100) FROM DUAL;


--지수
SELECT POWER(2,4) FROM DUAL;

--제곱근
SELECT SQRT(9) FROM DUAL;

--문자함수
--UPPER(소문자 -> 대문자)
SELECT UPPER('Oracle') FROM DUAL;

--LOWER(대문자 -> 소문자)
SELECT LOWER('ORACLE') FROM DUAL;

SELECT * FROM DIVISION WHERE DNAME = UPPER('sales');

SELECT * FROM DIVISION WHERE LOWER(DNAME)='sales';

--INITCAP
SELECT INITCAP('korea fighting') FROM DUAL;

--CONCAT(||)
SELECT PNAME || DNO FROM PERSONNEL;
SELECT CONCAT(PNAME, DNO) FROM PERSONNEL;


CREATE TABLE post (
	seq  NUMBER  NOT NULL
	,zipcode  VARCHAR2(10)
	,sido  VARCHAR2(50)
	,gugun  VARCHAR2(100)
	,dong  VARCHAR2(100)
	,bunji  VARCHAR2(50)
        ,PRIMARY KEY (seq)
);


SELECT * from post where dong like '행복%';

select sido || ' ' || gugun || ' ' || dong as juso from post where dong like '행복%';


--LENGTH
SELECT LENGTH('KOREA') FROM DUAL;
SELECT LENGTH('KOREA FIGHTING' FROM DUAL;

--SUBSTR
SELECT SUBSTR('ABCDEFG', 1, 3) FROM DUAL; --ABC
SELECT SUBSTR('ABCDEFG', 3, 2) FROM DUAL; --CD
SELECT SUBSTR('ABCDEFG', -3, 2) FROM DUAL; --EF
SELECT SUBSTR('ABCDEFG', -4) FROM DUAL; --DEFG


--INSTR
SELECT INSTR('ABCDEFG', 'C') FROM DUAL; --3

SELECT INSTR('AAAAAAA', 'A') FROM DUAL; --1
SELECT INSTR('ABCDEFG', 'a') FROM DUAL; --0

--RPAD/LPAD
SELECT RPAD(PNAME, 15, '*') FROM PERSONNEL;

--JUMIN
--941010-2018349

SELECT RPAD(SUBSTR('881104-1167811', 1, 8), 14, '*') JUMIN FROM DUAL;

--RTRIM/LTRIM
SELECT RTRIM('ABBBBBBB', 'B') FROM DUAL;
SELECT RTRIM('A       ', ' ') FROM DUAL; 

SELECT LTRIM('BBBABB', 'B') FROM DUAL;

--날짜 함수
--SYSDATE
SELECT SYSDATE FROM DUAL; --현재 날짜와 시간

SELECT SYSDATE-1,SYSDATE,SYSDATE+1 FROM DUAL; --어제,오늘,내일

--KIM사원이 현재까지 근무한 년 수
SELECT PNAME, ROUND((SYSDATE-STARTDATE)/365)||'년' 근속년수  FROM PERSONNEL WHERE PNAME='KIM';

--ROUND
SELECT STARTDATE,ROUND(STARTDATE,'YEAR') FROM PERSONNEL;
SELECT STARTDATE,ROUND(STARTDATE,'MONTH') FROM PERSONNEL;

--TRUNCATE
SELECT STARTDATE,TRUNC(STARTDATE,'YEAR') FROM PERSONNEL;
SELECT STARTDATE,TRUNC(STARTDATE,'MONTH') FROM PERSONNEL;

--MONTHS_BETWEEN(달의 수)
SELECT (MONTHS_BETWEEN(SYSDATE,'2002/06/01')) FROM DUAL;
SELECT TRUNC((MONTHS_BETWEEN(SYSDATE,'2002/06/01'))/12)달 FROM DUAL;

--LAST_DAY(말일)
SELECT STARTDATE,LAST_DAY(STARTDATE) FROM PERSONNEL;

--NEXT_DAY (돌아오는 날)
SELECT NEXT_DAY('2022-07-04 ','금요일') FROM DUAL; --오늘을 기준으로 돌아오는 금요일 시간이 0시로 고정
SELECT NEXT_DAY(SYSDATE,'금요일') FROM DUAL; --오늘을 기준으로 돌아오는 금요일

--ADD_MONTHS(개월 추가)
SELECT ADD_MONTHS(SYSDATE,24) FROM DUAL;

SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL
VALUES(2000,'HELOLKIM','SALESMAN',1116,'2022-07-04',5000,'',20);

SELECT * FROM PERSONNEL WHERE PNAME LIKE '%L__L%';

--------------------------------------------------------------------------------------------------------------------
--2022-07-05 강의 내용.

--변환함수
--TO_CHAR

/*
MM: 달(10)
MON: 3문자 달 이름(MAR)
MONTH: MARCH
DD: 일의 날짜수(22)
D:주의 일 수(2)
DY: 3자의 요일(MON)
DAY: MONTH
RM: 로마식 달수
YYYY: 2022
*/


SELECT SYSDATE, TO_CHAR(SYSDATE, 'D') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'RM') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YY-MM-DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'MM') FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, 'HH24:MI:SS') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'AM HH:MI:SSSS') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'PM HH:MI:SS') FROM DUAL;

SELECT TO_CHAR(12506, '99,999') FROM DUAL;
SELECT TO_CHAR(12506, '099,999') FROM DUAL;
SELECT TO_CHAR(12506, '9,999') FROM DUAL;
SELECT TO_CHAR(12506.99, '99,999.99') FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDSP') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDTH') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDSPTH') FROM DUAL;

--TO_DATE
SELECT TO_DATE('22-07-06', 'YY-MM-DD') FROM DUAL;
SELECT TO_DATE('11:05', 'HH24:MI') FROM DUAL;

--TO_NUMBER
SELECT TO_NUMBER('123')+1 FROM DUAL;
SELECT TO_NUMBER('ABC') FROM DUAL; --X 문자는 숫자로 변환이 불가능하다.

--NVL
SELECT BONUS, NVL2(BONUS, 'O', 'X') FROM PERSONNEL;

SELECT MANAGER FROM PERSONNEL;

SELECT MANAGER, NVL(TO_CHAR(MANAGER), 'NON MANAGER') FROM PERSONNEL;


SELECT SYSDATE, TO_CHAR(SYSDATE, 'YY') FROM DUAL;

SELECT SYSDATE, TO_CHAR(STARTDATE, 'YY') FROM PERSONNEL;

--DECODE(IF)
--각 사원의 급여를 부서가 10인 경우 10%, 부서가 20인 경우 20%, 나머지는 30%를 인상해서 출력.

SELECT PNAME, BONUS, DNO, PAY, DECODE(DNO, 10, PAY*1.1, 20, PAY*1.2, PAY*1.3) 인상분 FROM PERSONNEL;


--급여가 3500이상인 경우에는 'GOOD'표시, 미만인 경우에는 'POOR를 출력
SELECT PNAME, PAY, DECODE(SIGN(PAY - 3500), -1, 'POOR', 'GOOD') FROM PERSONNEL;



--그룹함수
--COUNT
SELECT COUNT(*) FROM PERSONNEL;	--10
SELECT COUNT(MANAGER) FROM PERSONNEL;	--9 NULL값을 안읽음
SELECT COUNT(BONUS) FROM PERSONNEL;	--3

--급여가 3000이상인 사원수
SELECT COUNT(*) FROM PERSONNEL WHERE PAY >= 3000;


--AVG
SELECT AVG(PAY) FROM PERSONNEL;

SELECT BONUS FROM PERSONNEL;

--BONUS의 평균을 구하시오
SELECT AVG(BONUS) FROM PERSONNEL;	--이렇게 하면 NULL값을 판단안해서 3으로 나눈다.
SELECT AVG(NVL(BONUS, 0)) FROM PERSONNEL;	--이건 NULL값도 같이 계산해서 10으로 나눔

--SUM
SELECT SUM(PAY) FROM PERSONNEL;

--MAX/MIN
SELECT MAX(PAY), MIN(PAY) FROM PERSONNEL;

--입사한지 가장 오래된 사원
SELECT MIN(STARTDATE) FROM PERSONNEL;

--입사한지 가장 오래된 사원과의 신입 사원과의 연차
SELECT ROUND((MAX(STARTDATE)-MIN(STARTDATE))/365)||'년' AS 연차 FROM PERSONNEL;


--분석함수

--부서별 평균 구하기
SELECT * FROM PERSONNEL ORDER BY DNO;
SELECT DISTINCT DNO, AVG(PAY) OVER(PARTITION BY DNO) B_AVG FROM PERSONNEL;

--월급 순위
SELECT PNAME, PAY, RANK() OVER (ORDER BY PAY DESC) RANK FROM PERSONNEL;


--1200을 받는 사원의 순위
SELECT RANK(1200) WITHIN GROUP(ORDER BY PAY DESC) RANK FROM PERSONNEL;

SELECT COUNT(*) FROM PERSONNEL; --단일값을 반환
SELECT PNAME FROM PERSONNEL;	--다중값 반환

SELECT PNAME FROM PERSONNEL WHERE PAY = 1600; --값은 하나만 출력되지만 다중값 중에서 선택하므로 이것도 다중값 반환이다.

SELECT PNAME, MIN(STARTDATE) FROM PERSONNEL;

SELECT PNO, PNAME, STARTDATE FROM PERSONNEL WHERE STARTDATE = (SELECT MIN(STARTDATE) FROM PERSONNEL);


--부서별 평균 급여를 구하시오
SELECT DNO, AVG(PAY) FROM PERSONNEL GROUP BY DNO;

--직업별 평균 급여, 인원수를 구하시오
SELECT JOB, TRUNC(AVG(PAY)), COUNT(JOB) FROM PERSONNEL GROUP BY JOB;

--각 부서의 평균 급여가 전체 평균 급여보다 크면 'GOOD', 작으면 'POOR'를 출력

SELECT ROUND(AVG(PAY)) FROM PERSONNEL;

SELECT DNO, AVG(PAY), DECODE(SIGN(AVG(PAY)-(SELECT ROUND(AVG(PAY)) FROM PERSONNEL)), 1, 'GOOD', 'POOR') GRADE FROM PERSONNEL GROUP BY DNO;

--HAVING: GROUP BY의 조건문(HAVING 뒤에 별칭을 사용할 수 없다.)
SELECT DNO, AVG(PAY) D_AVG FROM PERSONNEL GROUP BY DNO HAVING AVG(PAY) > 3000;

--SELECT - WHERE
--GROUP BY - HAVING

--부서인원이 2명보다 많은 부서의 부서번호, 급여의 합을 구하시오.
SELECT DNO, COUNT(*) CNT, SUM(PAY) SUM FROM PERSONNEL GROUP BY DNO HAVING COUNT(*) > 2;

--GROUP BY 가 잘 이해 안됨.

--JOIN문
--EQUIE JOIN(INNER JOIN)
--NON-EQUIE JOIN
--OUTER JOIN
--CROSS JOIN
--SELF JOIN


SELECT * FROM PERSONNEL;

SELECT A.PNO 사번, A.PNAME 직원, B.PNO 사번, B.PNAME 관리자
FROM PERSONNEL A, PERSONNEL B
WHERE A.MANAGER = B.PNO;


--NON-EQUIE JOIN	
SELECT * FROM PERSONNEL;
SELECT * FROM PAYGRADE;

SELECT PNAME, PAY, B.GRADE FROM PERSONNEL A, PAYGRADE B WHERE PAY BETWEEN LOWPAY AND HIGHPAY;


--OPERATOR
--A = [1, 2, 5, 6]
--B = [1, 2, 4]

--A UNION ALL B = [1, 2, 5, 6, 1, 2, 4]
--A UNION B = [1, 2, 4, 5, 6]
--A MINUS B = [5, 6] 차집합
--A INTERSECT B = [1, 2] 교집합

--UNION/ALL
SELECT * FROM PERSONNEL
UNION ALL
SELECT * FROM PERSONNEL;

--UNION
SELECT * FROM PERSONNEL
UNION
SELECT * FROM PERSONNEL;

--MINUS
SELECT DNO FROM DIVISION --10 20 30 40
MINUS
SELECT DNO FROM PERSONNEL;--10 20 30

--INTERSECT
SELECT DNO FROM DIVISION --10 20 30 40
INTERSECT
SELECT DNO FROM PERSONNEL;--10 20 30



SELECT * FROM TAB;
SELECT * FROM POST;
SELECT * FROM EXAM1;
SELECT * FROM MANAGER;


--틀만 복사하고 싶을때는 아래처럼 WHERE 부분을 거짓으로 주면 틀만 복사해준다.
--틀과 내용까지 복사는 WHERE부분을 참으로 주거나 WHERE부분을 적지 않으면 된다.
CREATE TABLE MANAGER
AS 
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE SALESMAN
AS 
	SELECT * FROM PERSONNEL
	WHERE 1=2;

CREATE TABLE BUSEO
AS SELECT * FROM DIVISION;

CREATE TABLE SAWON
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM1
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM2
AS SELECT * FROM DIVISION;

SELECT * FROM SALESMAN;

SELECT * FROM DIVISION;

INSERT INTO DIVISION VALUES(50, 'OPERATION', '031-123-4567', 'DAEGU');

SELECT * FROM DIVISION;
DESC DIVISION;

INSERT INTO DIVISION(DNO) VALUES(60);
INSERT INTO DIVISION(DNO, DNAME, POSITION) VALUES(70, 'ACCOUNT', 'DAEJUN');

DESC PERSONNEL;

INSERT INTO PERSONNEL (PNO, PNAME, PAY, DNO)
VALUES (7711, 'YOUNG', 4000, 20);

SELECT * FROM PERSONNEL;

DESC PERSONNEL;

INSERT INTO DIVISION VALUES(80, 'PLANNING', '010-123-1234', NULL);	--명시적 NULL삽입
INSERT INTO DIVISION VALUES(90, 'SERVICE', '010-222-3333', '');		--암시적 NULL삽입

SELECT * FROM DIVISION;

DESC PERSONNEL;

INSERT INTO PERSONNEL(PNO, PNAME, JOB, STARTDATE, DNO)
VALUES (1304, 'SUZI', 'SINGER', SYSDATE, 10);

SELECT * FROM PERSONNEL;

--치환변수(오라클만 가능)
SELECT PNO, PNAME, JOB, STARTDATE, DNO
FROM PERSONNEL
WHERE DNO= &D_NO;


--SELECT PNO, PNAME, JOB, &&COLUMN_NAME
--FROM PERSONNEL

SELECT * FROM TAB;
SELECT * FROM MANAGER;
--
--SELECT * FROM PERSONNEL
--WHERE JOB = 'MANAGER';

INSERT INTO MANAGER (PNO, PNAME, PAY, STARTDATE)
SELECT PNO, PNAME, PAY, STARTDATE FROM PERSONNEL WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER;

--업무가 SALESMAN인 사원의 모든정보를 SALESMAN 테이블로 복사

INSERT INTO SALESMAN
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN';

SELECT * FROM SALESMAN;

--UPDATE
SELECT * FROM PERSONNEL WHERE PNO = '1111';

UPDATE PERSONNEL SET DNO = 30 WHERE PNO = '1111';

UPDATE PERSONNEL SET PNAME = 'INNA', MANAGER = 1004, STARTDATE = SYSDATE, PAY = 8000
WHERE PNO = '1111';

SELECT PNO, PNAME, TO_CHAR(STARTDATE, 'YYYY-MM-DD') STARTDATE
FROM PERSONNEL WHERE PNO = '1111';

SELECT * FROM SAWON;

UPDATE SAWON SET DNO = 20;

--SUBQUERY로 UPDATE

SELECT * FROM PERSONNEL
WHERE DNO = (SELECT DNO FROM DIVISION WHERE DNAME = 'SALES');

SELECT PNO, PNAME, JOB, PAY FROM PERSONNEL
WHERE JOB = 'SALESMAN';

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM TAB;

SELECT A.*
FROM PERSONNEL A,DIVISION B
WHERE A.DNO = B.DNO AND DNAME='SALES';


--오라클은 조인으로 업데이트를 할수없음 
--MSSQL은 가능
UPDATE PERSONNEL SET JOB='SALESMAN'
FROM PERSONNEL A,DIVISION B
WHERE A.DNO = B.DNO AND DNAME='SALES';

ROLLBACK;

--테이블의 이름은 반드시 영문자로 시작해야한다.
--특수문자는 중간에만 들어갈수 있고 (_,$,#만 가능)
--중복불가, 컬럼명과 달라야한다
--예약어 사용 불가
--모든 테이블에는 반드시 하나의 프라이머리 키를 지정해줘야함
CREATE TABLE CUSINFO
(ID CHAR(5) PRIMARY KEY,
NAME CHAR(10),
JUMIN CHAR(14),
AGE NUMBER(3), --999까지 들어갈수 있음
ADDR VARCHAR2(100));

DESC CUSINFO;

INSERT INTO CUSINFO
VALUES ('10','SUZI','123456-1234567',50,'서울');

SELECT * FROM CUSINFO;
SELECT * FROM USER_CONSTRAINTS;

SELECT STARTDATE,
EXTRACT(YEAR FROM STARTDATE)YEAR, --: 년도만 추출 
EXTRACT(MONTH FROM STARTDATE)MONTH, --: 월만 추출 
EXTRACT(DAY FROM STARTDATE)DAY --: 일만 추출 
FROM PERSONNEL;
-----------------

-------------------------------------------------------------------
--DELETE

SELECT * FROM PERSONNEL WHERE PNO=2000;
DELETE FROM PERSONNEL WHERE PNO=2000;

SELECT * FROM PERSONNEL WHERE PNO=1111;
DELETE PERSONNEL WHERE PNO=1111; --FROM 생략 가능 !

--서브쿼리로 DELETE
SELECT * FROM DIVISION;

SELECT * FROM PERSONNEL 
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='FINANCE');

DELETE PERSONNEL
WHERE DNO=(SELECT DNO FROM DIVISION WHERE DNAME='FINANCE');

---------------------------------------------------------------------------
--INSERT ERROR
SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL (PNO,PNAME,DNO) 
VALUES (1113,'INNA',30); -- ERROR : UNIQUE 제약조건에 위배된다 

--제약조건을 보는 명령어
SELECT * FROM USER_CONSTRAINTS;

--UPDATE DRROR
--PERSONNEL의 DNO와 DIVISION의 DNO 참조관계
SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;

--외래키 찾을 수 없음
--parent key not found
--division 테이블에 51번이 없어서 제약조건에 걸림
UPDATE PERSONNEL SET DNO=51
WHERE DNO=20;

--DELETE ERROR
--child record found
--division에 20이 지워지면 personnel에 있는 20이 이상한 데이터가됨
DELETE DIVISION WHERE DNO=20; --x 불가능
DELETE DIVISION WHERE DNO=50; --o 가능 : 자식이 사용하고 있지 않기 때문에 

-------------------------------------------------------------------------------
--트랜잭션
--AUTO COMMIT : DDL/DCL은 자동커밋
--ROLLBACK : 비정상적인 종료시 직전커밋 까지

--------------------------------------------------------------------------------
--DDL : CREATE, ALTER, DROP
-------------------------------------------------------------

CREATE TABLE SALESMAN1
AS
SELECT PNO, PNAME, JOB, PAY FROM PERSONNEL
WHERE JOB = 'SALESMAN';

DESC SALESMAN1;

CREATE TABLE MANAGER1
AS
SELECT * FROM PERSONNEL
WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER1;

--PAY가 3000이상인 직원의 데이터를 PAY3000테이블 생성
CREATE TABLE PAY3000
AS
SELECT * FROM PERSONNEL
WHERE PAY >= 3000;


SELECT * FROM PAY3000;

CREATE TABLE MON12
AS
SELECT * FROM PERSONNEL
WHERE TO_CHAR(STARTDATE, 'MM') = '12' ;

DROP TABLE MON12 PURGE;

SELECT * FROM MON12;

SELECT STARTDATE FROM PERSONNEL WHERE STARTDATE LIKE '%12%';

SELECT * FROM PERSONNEL
WHERE TO_CHAR(STARTDATE, 'MM') = '04' ;

CREATE TABLE ANALYST(NUM, NAME, JOB, DNUM)
AS
SELECT PNO, PNAME, JOB, DNO FROM PERSONNEL
WHERE JOB = 'ANALYST';

SELECT * FROM ANALYST;

CREATE TABLE DIV10
AS
SELECT DNO, SUM(PAY) SUM_PAY FROM PERSONNEL
GROUP BY DNO
HAVING DNO = 10;

DROP TABLE DIV10 PURGE;

SELECT * FROM DIV10;

--테이블 구조 복사

SELECT * FROM PERSONNEL;

CREATE TABLE SAWON1
AS
SELECT * FROM PERSONNEL
WHERE 0=1;

SELECT * FROM SAWON1;

DESC PERSONNEL;
DESC SAWON1;

--테이블 수정
SELECT * FROM SALESMAN1;

DESC SALESMAN1;

--ADD(컬럼 추가)
ALTER TABLE SALESMAN1
ADD (NOD NUMBER(2));

INSERT INTO SALESMAN1 VALUES (1234, 'SUZI', 'SALESMAN', 3000, 10);

SELECT * FROM SALESMAN1;

ALTER TABLE SALESMAN1
ADD (JUMIN CHAR(14), ZIP CHAR(7));


SELECT * FROM SALESMAN1;

INSERT INTO SALESMAN1 VALUES (4444, 'INNA', 'SALESMAN', 2000, 10, '123456', '1234');

ALTER TABLE SALESMAN1
ADD BIGO VARCHAR2(10) DEFAULT('AA');

CREATE TABLE CUSINFO
(ID NUMBER(3) CONSTRAINT CUNSINFO PRIMARY KEY, 
NAME CHAR(10),
BIRTH DATE DEFAULT SYSDATE);

INSERT INTO CUSINFO (ID, NAME) VALUES (111, 'SUZI');

SELECT * FROM CUSINFO;

SELECT * FROM USER_CONSTRAINTS;

--INSERT시 CHECK를 해서 현재 정한 제약조건(SINGLE, MARRIED) 두개만 입력이 가능하다.
ALTER TABLE SALESMAN1
ADD (MARRIAGE CHAR(8) CONSTRAINT SALESMAN1_MARRIAGE_CK
CHECK (MARRIAGE IN ('SINGLE', 'MARRIED')));

SELECT * FROM SALESMAN1;

INSERT INTO SALESMAN1 VALUES
(5555, 'INSUN', 'SALESMAN', 2000, 10, '123456', '1234', 'BB', 'SINGLE');

DESC SALESMAN1;

ALTER TABLE SALESMAN1
ADD CONSTRAINT SALESMAN1_PNO_PK PRIMARY KEY(PNO);

SELECT * FROM USER_CONSTRAINTS;

--PK: 중복값 X, NULL X, 테이블 내에서 유일한 값
--UK: 중복값 X, NULL O, 테이블 내에서 여러개(256개) 가능
--CK: INSERT시 CHECK를 해서 현재 정한 제약조건 두개만 입력이 가능하다.
--NNKEY: MS-SQL에서는 NOT NULL이 안되고 DEFAULT를 제약조건으로 한다.

SELECT * FROM USER_CONSTRAINTS; --DICTIONARY;

ALTER TABLE MANAGER1
ADD COMM NUMBER(5);

DESC MANAGER1;

SELECT * FROM MANAGER1;

ALTER TABLE MANAGER1
ADD CONSTRAINT MANAGER1_PNO_PK PRIMARY KEY(PNO);

--MODIFY(컬럼수정)
SELECT * FROM MANAGER1;
DESC MANAGER1;

ALTER TABLE MANAGER1
MODIFY PNAME VARCHAR(16);

DESC MANAGER1;

ALTER TABLE MANAGER1
MODIFY PNAME VARCHAR(7) NOT NULL;

SELECT * FROM MANAGER1;
DESC MANAGER1;

SELECT * FROM USER_CONSTRAINTS; --DICTIONARY;

ALTER TABLE MANAGER1
DROP CONSTRAINT MANAGER1_PNO_PK;

ALTER TABLE SALESMAN1
DROP PRIMARY KEY;

ALTER TABLE DIVISION
DROP CONSTRAINT DIVISION_DNO_PK CASCADE;

SELECT * FROM DIVISION;

SELECT * FROM SALESMAN1;
DESC SALESMAN1;

ALTER TABLE SALESMAN1
DROP COLUMN MARRIAGE;

ALTER TABLE SALESMAN1
SET UNUSED COLUMN PNO;

ALTER TABLE SALESMAN1
DROP UNUSED COLUMN;

SELECT * FROM DBA_UNUSED_COL_TABS;

SELECT COUNT(*) FROM DICTIONARY;

--DROP(테이블 삭제)
SELECT * FROM TAB;

DROP TABLE SALESMAN1;

PURGE RECYCLEBIN;

SELECT * FROM RECYCLEBIN;

FLASHBACK TABLE SALESMAN1 TO BEFORE DROP;

DROP TABLE SALESMAN1 PURGE;

COMMIT;

--레코드 삭제
--TRUNCATE / DELETE

--DELETE (실행 시 트랜잭션 실행)
SELECT * FROM CUSINFO;

DELETE CUSINFO;

ROLLBACK;

SELECT * FROM CUSINFO;

COMMIT;

--TRUNCATE (트랜잭션이 실행되지 않고 바로 삭제 된다// 안쓰는 게 좋을 듯)
TRUNCATE TABLE CUSINFO;

SELECT * FROM CUSINFO;

ROLLBACK;

SELECT * FROM CUSINFO;

--RENAME(이름변경)
SELECT * FROM TAB;

SELECT * FROM PAY3000;

RENAME PAY3000 TO HIGHPAY;

SELECT * FROM HIGHPAY;

--COMMENT(주석)
SELECT * FROM USER_TAB_COMMENTS;

COMMENT ON TABLE HIGHPAY IS '월급 많이 받는 사람';

COMMENT ON TABLE HIGHPAY IS '';

COMMENT ON COLUMN HIGHPAY.PAY
IS '실 수령 금액';

SELECT * FROM USER_TAB_COMMENTS;

SELECT * FROM HIGHPAY;

COMMENT ON COLUMN HIGHPAY.PAY
IS '올해 보너스 없드아~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~';

SELECT * FROM USER_TAB_COMMENTS;
SELECT * FROM USER_COL_COMMENTS;

--DCL(GRANT, REVOKE)
--GRANT: USER나 OBJECT에서 권한을 부여할 때 사용
--REVOKE: USER나 OBJECT에서 권한을 회수할 때 사용

CREATE USER YOUNG
IDENTIFIED BY YOUNG
DEFAULT TABLESPACE USERS
TEMPORARY TABLESPACE TEMP;

--OBJECT권한
GRANT SELECT ON PERSONNEL TO TEST;
GRANT SELECT, INSERT, DELETE ON DIVISION TO TEST;

--ROLE을 가지고 있을 KIMOBJ라는 변수?를 선언
CREATE ROLE KIMOBJ;

--그 변수에 DIVISION을 SELECT, INSERT, DELETE 할 수 있는 권한을 넣음
GRANT SELECT, INSERT, DELETE ON DIVISION TO KIMOBJ;

GRANT KIMOBJ TO LEE;

SELECT * FROM ROLE_SYS_PRIVS;
SELECT * FROM USER_ROLE_PRIVS;

--제약조건(CONSTRAINT)
--PRIMARY KEY(PK)
--FOREIGN KEY(FK)
--UNIQUE KEY(UK)
--NOT NULL(NN)
--CHECK KEY(CK)

--DEFAULT(오라클에서는 제약조건이 아니지만 MS-SQL에서는 제약조건이다.)



















